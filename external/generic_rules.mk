# prevent re-entrency (metatargets are calling them selves, e.g COPY_HEADERS)
ifeq ($(_metatarget),)
# get the name of the metatarget (which is the name of our symlink)
# it has to be very first place, because include will alter the MAKEFILE_LIST)
_metatarget := $(basename $(notdir $(call original-metatarget)))
_need_prebuilts :=
ifneq (,$(findstring /PRIVATE/,$(abspath $(LOCAL_MODULE_MAKEFILE))))
_need_prebuilts := true
endif

ifneq (,$(_need_prebuilts))
# multi_prebuilt actually a shortcut to prebuilts, we support it to have a simpler output Android.mk
# but dont support all the flavors of multi_prebuilt
# we dont support the multi_prebuilt ':' syntax, fallback to normal prebuilt
# i.e. in multi_prebuilts, you can set LOCAL_PREBUILT_LIBS := <MODULE1>:<file1> <MODULE2>:<file2>
# this complexifies the implementation too much, so we fallback on the prebuilt backend we already implement
ifeq (multi_prebuilt,$(_metatarget))
 $(foreach var, LIBS EXECUTABLES LIBRARIES STATIC_JAVA_LIBRARIES,\
   $(if $(findstring :,$(LOCAL_PREBUILT_$(var))),\
	$(eval _metatarget:=)\
	))
endif
# if we are still multiprebuilt
ifeq (multi_prebuilt,$(_metatarget))
# if multi_prebuilt, we need to save the variables, because the original metatarget will
# call CLEAN_VARS
 $(foreach var, LIBS EXECUTABLES LIBRARIES STATIC_JAVA_LIBRARIES,\
   $(if $(LOCAL_PREBUILT_$(var)),\
     $(if $(IS_HOST_MODULE),\
       $(eval SAVED_HOST_$(var) := $(LOCAL_PREBUILT_$(var))),\
       $(eval SAVED_$(var) := $(LOCAL_PREBUILT_$(var)))\
     ))\
   )
endif
endif

########################################################################################
ifneq (custom_external, $(_metatarget))
include $(call original-metatarget)
endif
########################################################################################

# do nothing more if we are not in a PRIVATE dir
ifneq (,$(_need_prebuilts))

# device/intel/PRIVATE/ipp -> device/intel/prebuilts/blackbay/ipp
LOCAL_MODULE_PREBUILT_MAKEFILE := $(TARGET_OUT_prebuilts)/$(subst /PRIVATE/,/prebuilts/$(REF_PRODUCT_NAME)/,$(LOCAL_MODULE_MAKEFILE))
# local shortcut
my := $(LOCAL_MODULE_PREBUILT_MAKEFILE)

# we only define the commands once, even LOCAL_MODULE_PREBUILT_MAKEFILE may be defined
# via several metatargets (because the original Android.mk builds several things)

ifeq (,$($(LOCAL_MODULE_PREBUILT_MAKEFILE).ORIG_MAKEFILE))
$(LOCAL_MODULE_PREBUILT_MAKEFILE).ORIG_MAKEFILE := $(LOCAL_MODULE_MAKEFILE)
$(LOCAL_MODULE_PREBUILT_MAKEFILE).REF_PRODUCT_NAME := $(REF_PRODUCT_NAME)
# this variable in needed for substitution of ':' into a ',', as there is no escape in gnumake :-/
# http://blog.jgc.org/2007/06/escaping-comma-and-space-in-gnu-make.html
,:=,
# We only make one target to build the makefile (the ACPs are done in this target)
$(LOCAL_MODULE_PREBUILT_MAKEFILE): $(ACP) $(EXTERNAL_BUILD_SYSTEM)/generic_rules.mk
# cannot use $(LOCAL_MODULE_PREBUILT_MAKEFILE) or $(my) inside the rules, as they are expanded at rule running time
# while those two variables, are overriden at makefile parsing time
# we rebuild the whole directory every time to make sure there is no remaining files from previous build
	@mkdir -p $(dir $@)
	@rm -rf $(dir $@)/*
	@$(if $($@.copyfiles),\
		$(ACP) $($@.copyfiles) $(dir $@),)
	@echo '# autogenerated Android.mk' > $@
	@echo 'ifeq ($($@.REF_PRODUCT_NAME),$$(wildcard $($@.ORIG_MAKEFILE))$$(REF_PRODUCT_NAME))# test inexistance of original makefile, and correct ref product ' >> $@
	@echo 'LOCAL_PATH := $$(call my-dir)' >> $@
	@echo '# TARGET binaries' >> $@
	@echo 'LOCAL_IS_HOST_MODULE:=' >> $@
	@$(foreach class, LIBS EXECUTABLES JAVA_LIBRARIES STATIC_JAVA_LIBRARIES, \
		$(call external-echo-prebuilt,$(class)))
	@echo 'include $$(BUILD_MULTI_PREBUILT)' >> $@
	@$(if $($@.hashosts), \
		$(call external-echo-makefile, 'include $$(CLEAN_VARS)') \
		$(call external-echo-makefile, '# HOST binaries' ) \
		$(call external-echo-makefile, 'LOCAL_IS_HOST_MODULE:=true' ) \
		$(foreach class, LIBS EXECUTABLES JAVA_LIBRARIES STATIC_JAVA_LIBRARIES, \
			$(call external-echo-prebuilt,$(class),_HOST)) \
		$(call external-echo-makefile, 'include $$(BUILD_MULTI_PREBUILT)'))
	@echo 'include $$(CLEAN_VARS)' >> $@
	@$(foreach to, $($@.headers_to), \
		echo 'LOCAL_COPY_HEADERS:=$($@.headers.$(to))' >> $@; \
		echo 'LOCAL_COPY_HEADERS_TO:=$(to)' >> $@; \
		echo 'include $$(BUILD_COPY_HEADERS)' >> $@;)
	@$(foreach key, $($@.prebuilt), \
	  	$(eval args :=  $(subst :,$(,),$(key))) \
		echo '$$(call auto-prebuilt-boilerplate $($@.prebuilt.$(key)),$(subst $(PRODUCT_OUT),$$(PRODUCT_OUT),$(args)))' >> $@;)
	@$(if $($@.PACKAGES),\
		echo '$$(call auto-prebuilt-boilerplate $($@.PACKAGES),,APPS,optional)' >> $@;)
	@$(foreach mk, $($@.extramakefile), \
		cat $(mk) >> $@;)
	@echo 'endif' >> $@

endif
# this implement mapping between metatarget names, and what multi_prebuilt is waiting for
$(eval $(call external-gather-files,executable,EXECUTABLES))
$(eval $(call external-gather-files,shared_library,LIBS))
$(eval $(call external-gather-files,static_library,LIBS))
$(eval $(call external-gather-files,host_executable,HOST_EXECUTABLES))
$(eval $(call external-gather-files,host_shared_library,HOST_LIBS))
$(eval $(call external-gather-files,host_static_library,HOST_LIBS))
$(eval $(call external-gather-files,java_library,JAVA_LIBRARIES))
$(eval $(call external-gather-files,static_java_library,STATIC_JAVA_LIBRARIES))
$(eval $(call external-gather-files,package,PACKAGES))

# some metatargets also include copy_headers implicitly
ifneq ($(filter copy_headers executable shared_library static_library,$(_metatarget)),)
   $(my).copyfiles := $($(my).copyfiles) $(foreach h,$(LOCAL_COPY_HEADERS),$(LOCAL_PATH)/$(h))
   $(my).headers_to := $($(my).headers_to) $(LOCAL_COPY_HEADERS_TO)
   $(my).headers.$(LOCAL_COPY_HEADERS_TO) := $($(my).headers.$(LOCAL_COPY_HEADERS_TO)) $(foreach h,$(LOCAL_COPY_HEADERS),$(notdir $(h)))
endif

# prebuilt is a bit special, it has a lot of arguments...
# we'll use auto-prebuilt-boilerplate, which is a macro defined by multi_prebuilt.mk
ifneq ($(filter prebuilt,$(_metatarget)),)
   $(my).copyfiles := $($(my).copyfiles) $(foreach f,$(LOCAL_SRC_FILES),$(LOCAL_PATH)/$(f))
   $(if $(word 2,$(LOCAL_MODULE_TAGS)), \
     $(info $(LOCAL_PATH): external script does not support multiple tags: $(LOCAL_MODULE_TAGS) in prebuilt using optional instead) $(eval LOCAL_MODULE_TAGS:=optional))

   # we build a key with all the parameters, ordered by auto-prebuilt-boilerplate argument
   # we'll replace ':' by ',' in order to directly call auto-prebuilt-boilerplate
   # we need to be 100% sure that there is no white space in this variable
   prebuilt_key := $(strip $(LOCAL_IS_HOST_MODULE)):$(strip $(LOCAL_MODULE_CLASS)):$(strip $(LOCAL_MODULE_TAGS)):$(strip $(OVERRIDE_BUILT_MODULE_PATH)):$(strip $(LOCAL_UNINSTALLABLE_MODULE)):$(strip $(LOCAL_BUILT_MODULE_STEM)):$(strip $(LOCAL_STRIP_MODULE)):$(strip $(LOCAL_MODULE))
   # maintain a list of all possible combinations of parameters
   $(my).prebuilt := $($(my).prebuilt) $(prebuilt_key)
   $(my).prebuilt.$(prebuilt_key) := $($(my).prebuilt.$(prebuilt_key)) $(foreach h,$(LOCAL_SRC_FILES),$(notdir $(h)))
endif
ifneq ($(filter custom_external,$(_metatarget)),)
   $(my).copyfiles := $($(my).copyfiles) $(LOCAL_BUILT_MODULE)
   $(my).extramakefile := $($(my).extramakefile) $(LOCAL_PATH)/external_Android.mk
endif

###################################### dependencies #########################################
$(LOCAL_MODULE_PREBUILT_MAKEFILE): $($(LOCAL_MODULE_PREBUILT_MAKEFILE).copyfiles)
ALL_MODULES.$(LOCAL_INSTALLED_MODULE).PREBUILT_MAKEFILE := \
          $(strip $(ALL_MODULES.$(LOCAL_INSTALLED_MODULE).PREBUILT_MAKEFILE)) $(LOCAL_MODULE_PREBUILT_MAKEFILE)


###################################### cleanups of local variables #########################################

# cleanup local shortcut for LOCAL_MODULE_PREBUILT_MAKEFILE
my :=
endif # is /PRIVATE/
_metatarget :=
_need_prebuilts :=
else # metatarget neq ''
include $(call original-metatarget)
endif
