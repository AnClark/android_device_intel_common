# prevent re-entrency (metatargets are calling them selves, e.g COPY_HEADERS)
ifeq ($(_metatarget),)
# get the name of the metatarget (which is the name of our symlink)
# it has to be very first place, because include will alter the MAKEFILE_LIST)
_metatarget := $(basename $(notdir $(call original-metatarget)))
_need_prebuilts :=
$(foreach project, $(_prebuilt_projects),\
  $(if $(findstring $(project), $(LOCAL_MODULE_MAKEFILE)),\
    $(eval _need_prebuilts := true)))

# We don't handle multi_prebuilt directly,
# but handle prebuilt metatarget when it is called by original multi_prebuilt
ifeq (multi_prebuilt, $(_metatarget))
_need_prebuilts :=
_metatarget :=
endif

# Do not release prebuilts for tests modules
ifneq (,$(filter $(LOCAL_MODULE_TAGS), tests))
_need_prebuilts :=
endif

ifneq (,$(_need_prebuilts))
ifeq ($(findstring /PRIVATE/, $(LOCAL_MODULE_MAKEFILE)),)
$(error External framework does not support prebuilt for non PRIVATE path: $(LOCAL_MODULE_MAKEFILE))
_need_prebuilts :=
endif
endif

########################################################################################
ifneq (custom_external, $(_metatarget))
include $(call original-metatarget)
endif

########################################################################################

# do nothing more if we don't need prebuilts
ifneq (,$(_need_prebuilts))

# Record if this is a host module, to split host and target files in 2 different folders
# because a host and a target module can have same module name
ifeq ($(LOCAL_IS_HOST_MODULE), true)
    module_type :=  host
else
    module_type :=  target
endif

# transform the name of output dir,
# e.g. [/android_tree/]vendor/intel/PRIVATE/ipp -> vendor/intel/prebuilts/blackbay/ipp
# src makefile is renamed Android.mk in prebuilts out directory
_prj_path := $(dir $(patsubst $(ANDROID_BUILD_TOP)/%,%,$(LOCAL_MODULE_MAKEFILE)))
LOCAL_MODULE_PREBUILT_MAKEFILE := $(PRODUCT_OUT)/$(call intel-prebuilts-path,$(_prj_path))Android.mk
# local shortcut
my := $(LOCAL_MODULE_PREBUILT_MAKEFILE)

# we only define the commands once, even LOCAL_MODULE_PREBUILT_MAKEFILE may be defined
# via several metatargets (because the original Android.mk builds several things)

ifeq (,$($(LOCAL_MODULE_PREBUILT_MAKEFILE).ORIG_MAKEFILE))
$(LOCAL_MODULE_PREBUILT_MAKEFILE).ORIG_MAKEFILE := $(LOCAL_MODULE_MAKEFILE)
$(LOCAL_MODULE_PREBUILT_MAKEFILE).REF_PRODUCT_NAME := $(REF_PRODUCT_NAME)

# We only make one target to build the makefile (the ACPs are done in this target)
$(LOCAL_MODULE_PREBUILT_MAKEFILE): $(ACP) $(EXTERNAL_BUILD_SYSTEM)/generic_rules.mk
# cannot use $(LOCAL_MODULE_PREBUILT_MAKEFILE) or $(my) inside the rules, as they are expanded at rule running time
# while those two variables, are overriden at makefile parsing time
# we rebuild the whole directory every time to make sure there is no remaining files from previous build
# We don't remove the whole directory but only the files at first level, else we might have conflicts between
# cascaded Android.mk, when building with -j x option
	@mkdir -p $(dir $@)
	@find $(dir $@) -maxdepth 1 -type f -exec rm -f {} +
	@$(if $($@.copyfiles),\
		$(call copy-several-files, $($@.copyfiles)),)
	@echo '# autogenerated Android.mk' > $@
	@echo 'ifeq ($($@.REF_PRODUCT_NAME),$$(wildcard $($@.ORIG_MAKEFILE))$$(REF_PRODUCT_NAME))# test inexistance of original makefile, and correct ref product' >> $@
	@echo 'LOCAL_PATH := $$(call my-dir)' >> $@
	@$(foreach type, host target, \
		$(foreach class, PACKAGES PREBUILT LIBS EXECUTABLES JAVA_LIBRARIES STATIC_JAVA_LIBRARIES \
					HOST_LIBS HOST_EXECUTABLES HOST_JAVA_LIBRARIES HOST_STATIC_JAVA_LIBRARIES, \
			$(foreach module, $($@.$(type).$(class).LOCAL_INSTALLED_STEM_MODULES), \
				$(call external-auto-prebuilt-boilerplate, \
					$(type)/$($@.$(type).$(class).$(module).LOCAL_INSTALLED_MODULE_STEM), \
					$($@.$(type).$(class).$(module).LOCAL_IS_HOST_MODULE), \
					$($@.$(type).$(class).$(module).LOCAL_MODULE_CLASS), \
					$($@.$(type).$(class).$(module).LOCAL_MODULE_TAGS), \
					$($@.$(type).$(class).$(module).OVERRIDE_BUILT_MODULE_PATH), \
					$($@.$(type).$(class).$(module).LOCAL_UNINSTALLABLE_MODULE), \
					$($@.$(type).$(class).$(module).LOCAL_BUILT_MODULE_STEM), \
					$($@.$(type).$(class).$(module).LOCAL_STRIP_MODULE), \
					$($@.$(type).$(class).$(module).LOCAL_MODULE), \
					$($@.$(type).$(class).$(module).LOCAL_INSTALLED_MODULE_STEM), \
					$($@.$(type).$(class).$(module).LOCAL_CERTIFICATE), \
					$($@.$(type).$(class).$(module).LOCAL_MODULE_PATH), \
					$($@.$(type).$(class).$(module).LOCAL_REQUIRED_MODULES), \
					$($@.$(type).$(class).$(module).LOCAL_SHARED_LIBRARIES)))))
	@$(foreach to, $($@.headers_to), \
		$(if $(filter _none_,$(to)), \
			$(eval _to_:=),\
			$(eval _to_:=$(to))) \
		$(if $(strip $($@.headers.$(to))), \
			$(call external-echo-makefile, '') \
			$(call external-echo-makefile, 'include $$(CLEAR_VARS)') \
			$(call external-echo-makefile, 'LOCAL_COPY_HEADERS:=$(strip $($@.headers.$(to)))') \
			$(call external-echo-makefile, 'LOCAL_COPY_HEADERS_TO:=$(strip $(_to_))') \
			$(call external-echo-makefile, 'include $$(BUILD_COPY_HEADERS)')))
	@$(foreach mk, $($@.extramakefile), \
		$(call external-echo-makefile, '') \
		cat $(mk) >> $@;)
	@$(foreach module, $($@.phony), \
		$(call external-phony-package-boilerplate, \
			$(module), \
			$($@.phony.$(module).LOCAL_REQUIRED_MODULES)))
	@echo 'endif' >> $@
endif

# When odex is generated, .dex files are removed but .dex files should
# be saved for external release as they can be used to rebuild a component
# while odex can't. This requires patches in AOSP /build/ project.
ifeq (INTEL_PREBUILTS_JAVA_BACKUP_DEX, true)
EXT_JAVA_BACKUP_SUFFIX := .dex
endif

# this implement mapping between metatarget names, and what prebuilt is waiting for
$(call external-gather-files,executable,EXECUTABLES)
$(call external-gather-files,shared_library,LIBS)
$(call external-gather-files,static_library,LIBS)
$(call external-gather-files,host_executable,HOST_EXECUTABLES)
$(call external-gather-files,host_shared_library,HOST_LIBS)
$(call external-gather-files,host_static_library,HOST_LIBS)
$(call external-gather-files,java_library,JAVA_LIBRARIES,$(EXT_JAVA_BACKUP_SUFFIX))
$(call external-gather-files,static_java_library,STATIC_JAVA_LIBRARIES)
$(call external-gather-files,package,PACKAGES,$(EXT_JAVA_BACKUP_SUFFIX))
$(call external-gather-files,prebuilt,PREBUILT)

# some metatargets also include copy_headers implicitly
ifneq ($(filter copy_headers executable shared_library static_library,$(_metatarget)),)
   $(my).copyfiles := $($(my).copyfiles) $(foreach h,$(LOCAL_COPY_HEADERS),$(LOCAL_PATH)/$(h):$(dir $(my))include/$(notdir $(h)))
ifeq ($(LOCAL_COPY_HEADERS_TO),)
   LOCAL_COPY_HEADERS_TO := _none_
endif
   $(my).headers_to := $($(my).headers_to) $(LOCAL_COPY_HEADERS_TO)
   $(my).headers.$(LOCAL_COPY_HEADERS_TO) := $($(my).headers.$(LOCAL_COPY_HEADERS_TO)) $(foreach h,$(LOCAL_COPY_HEADERS),include/$(notdir $(h)))
endif

ifneq ($(filter custom_external,$(_metatarget)),)
ifneq ($(LOCAL_BUILT_MODULE),)
   $(my).copyfiles := $($(my).copyfiles) $(LOCAL_BUILT_MODULE):$(dir $(my))$(module_type)/$(notdir $(LOCAL_BUILT_MODULE))
endif
   $(my).extramakefile := $($(my).extramakefile) $(LOCAL_PATH)/external_Android.mk
endif
# another special case with phony_package, which is a way to define a metapackage that justs
# depends on other packages
ifneq ($(filter phony_package,$(_metatarget)),)
   $(my).phony := $($(my).phony) $(LOCAL_MODULE)
   $(my).phony.$(LOCAL_MODULE).LOCAL_REQUIRED_MODULES := $(LOCAL_REQUIRED_MODULES)
endif

###################################### dependencies #########################################
$(LOCAL_MODULE_PREBUILT_MAKEFILE): $(LOCAL_MODULE_MAKEFILE)
$(LOCAL_MODULE_PREBUILT_MAKEFILE): $(call several-files-deps, $($(LOCAL_MODULE_PREBUILT_MAKEFILE).copyfiles))
# If the module is installable, we store the prebuilt makefile to ALL_MODULES.$(LOCAL_INSTALLED_MODULE).PREBUILT_MAKEFILE.
# This will allow to filter dependencies of intel_prebuilts target, based on what is installed.
# For other modules like static or host classes, which are not installable, we store the prebuilt makefile to a single variable.
# This is the same for copy_headers metatarget which does not define a module.
# We use the sort function to remove duplicates from dependencies list.
ifneq ($(filter shared_library executable raw_executable package java_library native_test prebuilt phony_package,$(_metatarget)),)
    ifndef LOCAL_UNINSTALLABLE_MODULE
        ALL_MODULES.$(LOCAL_INSTALLED_MODULE).PREBUILT_MAKEFILE := \
            $(sort $(strip $(ALL_MODULES.$(LOCAL_INSTALLED_MODULE).PREBUILT_MAKEFILE)) $(LOCAL_MODULE_PREBUILT_MAKEFILE))
    else
        # This brings all uninstallable modules (mainly static libs).
        INTEL_PREBUILTS_MAKEFILE := $(sort $(strip $(INTEL_PREBUILTS_MAKEFILE)) $(LOCAL_MODULE_PREBUILT_MAKEFILE))
    endif
else
    # This brings all makefiles containing copy_headers (and others?).
    INTEL_PREBUILTS_MAKEFILE := $(sort $(strip $(INTEL_PREBUILTS_MAKEFILE)) $(LOCAL_MODULE_PREBUILT_MAKEFILE))
endif

###################################### cleanups of local variables #########################################

# cleanup local shortcut for LOCAL_MODULE_PREBUILT_MAKEFILE
my :=
endif # is /PRIVATE/
_metatarget :=
_need_prebuilts :=
else # metatarget neq ''
include $(call original-metatarget)
endif
